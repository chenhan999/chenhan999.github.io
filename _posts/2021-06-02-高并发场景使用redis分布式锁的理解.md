---
layout:     post
title:      高并发
subtitle:   2021-06-02-高并发场景使用redis分布式锁的理解
date:       2021-06-02
author:     Han
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 高并发
---

## 高并发下的一些场景 解决方案理解  redis锁

> 以一个简单的超卖场景为基础 ;  扩展一些问题场景
    
* 场景1 
在高并发场景之下，多个请求扣减库存 ，会导致超卖的场景；

>> 此时我们可以通过synchronized或者lock相关api解决并发问题;

*** 

* 场景2
实际线上环境中.我们往往是集群部署,而syn和lock都是jvm层级上面的锁,无法满足我们的需求;

>> 此时我们可以使用redis的单线程模型把请求串行化:  setnx 命令  set if not exists
线程1请求过来 setnx 获取锁 , 线程2请求过来setnx失败 ,请求等待释放锁;


* 场景3 
线程1的请求在执行过程中抛出异常 . 锁未释放 ,后续所有请求都将被hold住;

>> 在finally 中写释放逻辑;


* 场景4
线程1的请求还未执行完成.此时服务崩了,锁未释放 ,后续所有请求都将被hold住;

>> 可以通过expire命令设置一个锁的过期时间;

* 场景5
设置锁过期时间的时候抛异常或者宕机; (setnx和expire非原子操作)

>> redis后面的版本把两个命令通过lua脚本实现了原子操作  setnx中有个参数为过期时间;


* 场景6
假设设置了10s的超时时间,线程1请求进来执行业务逻辑超过10s , 锁被自动释放, 此时线程2请求进来setnx成功 , 获取锁 , 线程1执行完成 释放锁,此时释放的其实是线程2的锁;
在高并发场景下可能会导致某个时间段内锁失效 , 导致并发问题

>> 通过线程id作为redis中的value值,释放时 判断是否是当前线程自己的锁;

* 场景7
在判断线程id是否相等的逻辑和释放锁的逻辑中,出现了卡顿情况 
```
finlly{

    if(当前线程id .equals(redis.get(key))){
        
        // 程序在这里出现卡顿的场景    或者说程序执行到这里 锁到了过期时间自动过期;
        
        redis.delete(key)
    
    }
}
```
在这种情况下, 程序进入了if逻辑 -> 锁的过期时间到了 自动释放锁 -> 线程2 setnx成功 获取锁 -> 线程1 执行delete操作 , 此时还是出现了删除别人线程锁的情况;

> 给锁续命 , 另外开一个线程 判断锁线程是否执行完毕,没有执行完就重新设置过期时间;  实现较难  市面的分布式锁 redisson 的watch dog 看门狗就是一个锁续命实现;


* 场景8 
生产中redis也是集群部署,线程1请求的锁写到了master , 还未同步给slave , 此时master挂掉了,salve成为新的master ,  
线程2 setnx 命令发送到新的master , 新的master中没有该锁,则重复获取到了锁

> 这个问题使用redis / redisson 无法解决; 因为redis是AP模型, 考虑的是高可用, 当写入redis的时候,master写入成功则返回给client , 再同步给其他redis节点;
  
> 考虑这样的场景可以使用zk的分布式锁 , 因为zk是CP模型,考虑的是数据一致性, 当写入zk的时候,master写入成功之后会同步该数据给其他节点, 同步完成之后才会返回client写成功;

> redLock , 也是基于redis的分布式锁 , 实现方面和zk类似, 可以满足场景8 ; 但是不推荐使用 bug较多;
 
* 分布式锁 , 请求串行  , 性能如何优化 ? 


## 高并发下的一些场景 解决方案理解  redis缓存

* 1 
双写一致性问题;

> 延时双删策略;
