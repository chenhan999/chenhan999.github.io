---
layout:     post
title:      记一次sentinel排错,集群限流配置
subtitle:   记一次sentinel排错
date:       2020-05-01
author:     Han
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Spring Cloud alibaba
---

问题描述：

最近要新加sentinel集群限流，找到以前配置好的sentinel，naocs，控制台代码，在调试过程中发现通过Sentinel控制台提交流控规则，提交之后页面未展示规则，且规则未生效，而nacos中显示规则文件已保存。

背景：

1.nacos已经修改为mysql做持久化。

2.单机限流，规则持久化等等功能之前就已调试好，并未发现此问题。

3.注册在naocs中的服务，能读取到配置文件，且能正常启动。

4.新生成的限流文件配置不能正常读取。

Sentinel控制台页面未展示，说明控制台中未从nacos查询到数据，debug Sentinel源码发现获取nacos中的规则是通过如下nacos提供的api
http://10.157.109.30:8848/nacos/v1/cs/configs?dataId=E-Confirmation-Gateway-flow-rules&group=SENTINEL_GROUP&tenant=17be4b44-6c1e-4345-bc00-3137e494e568&namespaceId=17be4b44-6c1e-4345-bc00-3137e494e568
直接访问 返回config data not exist 确实不存在，但是为什么nacos页面上能查询到规则且展示出来？

页面F12发现其实页面上展示的数据是通过另外一个接口查询， 多了一个show=all参数
查阅nacos源码，发现第二个接口是直接从mysql查询所有信息 包括namespace等等。
```
    @GetMapping(params = "show=all")
    @Secured(action = ActionTypes.READ, parser = ConfigResourceParser.class)
    public ConfigAllInfo detailConfigInfo(HttpServletRequest request, HttpServletResponse response,
                                          @RequestParam("dataId") String dataId, @RequestParam("group") String group,
                                          @RequestParam(value = "tenant", required = false,
                                              defaultValue = StringUtils.EMPTY) String tenant)
        throws NacosException {
        // check params
        ParamUtils.checkParam(dataId, group, "datumId", "content");
        return persistService.findConfigAllInfo(dataId, group, tenant);
    }
```

```
    public ConfigAllInfo findConfigAllInfo(final String dataId, final String group, final String tenant) {
        final String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant;
        try {
            List<String> configTagList = this.selectTagByConfig(dataId, group, tenant);
            ConfigAllInfo configAdvance = this.jt.queryForObject(
                "SELECT ID,data_id,group_id,tenant_id,app_name,content,md5,gmt_create,gmt_modified,src_user,src_ip,c_desc,c_use,effect,type,c_schema FROM config_info WHERE data_id=? AND group_id=? AND tenant_id=?",
                new Object[]{dataId, group, tenantTmp}, CONFIG_ALL_INFO_ROW_MAPPER);
            if (configTagList != null && !configTagList.isEmpty()) {
                StringBuilder configTagsTmp = new StringBuilder();
                for (String configTag : configTagList) {
                    if (configTagsTmp.length() == 0) {
                        configTagsTmp.append(configTag);
                    } else {
                        configTagsTmp.append(",").append(configTag);
                    }
                }
                configAdvance.setConfigTags(configTagsTmp.toString());
            }
            return configAdvance;
        } catch (EmptyResultDataAccessException e) { // 表明数据不存在, 返回null
            return null;
        } catch (CannotGetJdbcConnectionException e) {
            fatalLog.error("[db-error] " + e.toString(), e);
            throw e;
        }
    }
```

第一个接口（Sentinel中调用的接口）找到错误信息代码处 代码片段如下：

```

                            md5 = cacheItem.getMd5();
                            lastModified = cacheItem.getLastModifiedTs();
                            if (STANDALONE_MODE && !PropertyUtil.isStandaloneUseMysql()) {
                                configInfoBase = persistService.findConfigInfo(dataId, group, tenant);
                            } else {
                                file = DiskUtil.targetFile(dataId, group, tenant);
                            }
                            if (configInfoBase == null && fileNotExist(file)) {
                                // FIXME CacheItem
                                // 不存在了无法简单的计算推送delayed，这里简单的记做-1
                                ConfigTraceService.logPullEvent(dataId, group, tenant, requestIpApp, -1,
                                    ConfigTraceService.PULL_EVENT_NOTFOUND, -1, requestIp);

                                // pullLog.info("[client-get] clientIp={}, {},
                                // no data",
                                // new Object[]{clientIp, groupKey});

                                response.setStatus(HttpServletResponse.SC_NOT_FOUND);
                                response.getWriter().println("config data not exist");
                                return HttpServletResponse.SC_NOT_FOUND + "";
```

其中`STANDALONE_MODE` 为系统参数，参看naocs启动脚本发现设置为true 
`PropertyUtil.isStandaloneUseMysql()`  在nacos的配置文件中配置为mysql 返回true 
故if (STANDALONE_MODE && !PropertyUtil.isStandaloneUseMysql()) 为flase 进入else逻辑，而该逻辑可以看出是用磁盘读取文件的形式获得规则信息

接着往下走，当从mysql获取的数据与从文件读取的数据都为空时，返回config data not exist。
至此，可以看出问题出在了从服务器读取文件。进入targetFile方法
找到
``` static final String BASE_DIR = File.separator + "data" + File.separator + "config-data";
    static final String TENANT_BETA_DIR = File.separator + "data" + File.separator + "tenant-beta-data";
```
文件存放路径，登录服务器，发现里面存放的文件最早都是1个月之前的。

测试1.

在本地注册一个服务到nacos，正常启动。能获取到配置文件
尝试在nacos控制台备份、删除、恢复该服务端的yml配置文件，发现原本在naocs文件夹中的文件删除之后无法自动生成。
再次在本地注册一个服务到nacos，启动时报错，无法找到配置文件，印证了代码逻辑。

测试2.
本地重新启动一个nacos服务（nacos版本与服务器上的一致），重复测试1操作，页面上新增配置，服务器同步新增文件，服务正常启动，能读取配置。

怀疑是开发环境的nacos服务端出现了某些问题，尝试重启nacos服务，无相关权限，寻求运维同事帮忙重启，而无法正常重启，发现重启时会报出一个磁盘文件已满的错误，恍然大悟，
通过sentinel新增的规则正是因为磁盘已满，故而无法保存规则文件，而之前保存的文件还在，所以会出现老配置能读取，新增配置无法读取的现象。

而磁盘满的问题之前就遇见过，是因为nacos会保存一个access日志，记录naocs所有的请求信息，包括心跳请求等等接口都会记录，所以这个日志文件十分大，在此之前已手动删除过一次。

解决方案：

1.手动删除access日志

2.设置nacos不记录该日志
在/nacos/config目录下有一个application.propertites配置文件中配置
```
server.tomcat.accesslog.enabled=false
```